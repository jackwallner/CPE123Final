//Main File for the CPE 123 Project

//Timeline
int scene;
int s1;
int s2;

/* DECLARE VARIABLES */
// for fish
int fishNumber = 20;
float fishTime = 3;
float fishEyeMove = 0, fishTailMove = 0;
boolean fishTailSwitch = false;
//boolean fishAnimate = false;
// for FirstFish
int FirstFishNumber = 1;
float FirstFishTime = 2.2;
float FirstFishEyeMove = 0, FirstFishTailMove = 0;
boolean FirstFishTailSwitch = false;
boolean FirstFishAnimate = false;
float fx, fy;
int FirstFishPX;
// for seaweeds
float theta=0.0;
float zeta=0.0;
float beta=0.0;
float eta=0.0;
int end1;
int swap;
int px;
int py;
// for sea monster
float monsterzeta=0;
// for boat
float bpy;
float brotate;
boolean boatD = false;
boolean boatP = false;

/* DECLARE ARRAYS */
// for fish
PVector fishLoc[];
PVector fishDir[];
float fishScale[];
float fishRotate[];
color fishColor[];
color fishEyeColor[];
// for FirstFish
PVector FirstFishLoc[];
PVector FirstFishDir[];
float FirstFishScale[];
float FirstFishRotate[];
color FirstFishColor[];
color FirstFishEyeColor[];

//background color

color underwater;
color sky;
color bC;

// Declare Arrays for seaweed

int sweedY[];
int sweedYback[];
int back[];

//moving above water

float wy;
int waterlevel;

//Setup Function
void setup() {
  size(1280, 720);
  background(18, 170, 190);
  //seaweed setup
  s1 = 500;
  s2 = 0;
  swap = 0;
  scene = 0;
  fx = width*1.15;
  fy = height/2-120;
  px = -800;
  py = height/2;
  wy = -100;
  //boat setup
  brotate = 0;
  bpy= -425;


  // initializing arrays for fish 
  fishLoc = new PVector[fishNumber];
  fishDir = new PVector[fishNumber];
  fishScale = new float[fishNumber];
  fishRotate = new float[fishNumber];
  fishColor = new color[fishNumber];
  fishEyeColor = new color[fishNumber];
  // for fish
  for (int i = 0; i < fishNumber; i++) {
    fishLoc[i] = new PVector(width*-.1, (height-70)/fishNumber*i+40);
    fishDir[i] = new PVector(random(0.8, 1.7), 0);
    fishScale[i] = random(0.15, 0.65);
    //fishRotate[i] = random(radians(-30), radians(30));
    fishColor[i] = color(random(0, 255), random(0, 255), random(0, 255));
    fishEyeColor[i] = color(random(225, 255));
  }

  // initializing arrays for FirstFish 
  FirstFishLoc = new PVector[FirstFishNumber];
  FirstFishDir = new PVector[FirstFishNumber];
  FirstFishScale = new float[FirstFishNumber];
  FirstFishRotate = new float[FirstFishNumber];
  FirstFishColor = new color[FirstFishNumber];
  FirstFishEyeColor = new color[FirstFishNumber];
  // for FirstFish
  for (int i = 0; i < FirstFishNumber; i++) {
    FirstFishLoc[i] = new PVector(width*1.15, height/2-120);
    FirstFishDir[i] = new PVector(-1, 0);
    FirstFishScale[i] = -1;
    FirstFishRotate[i] = random(radians(-30), radians(30));
    FirstFishColor[i] = color(200, 0, 0);
    FirstFishEyeColor[i] = color(255);
  }

  //seaweed transition vectors
  sweedY = new int[7];
  sweedY[0] = 320;
  sweedY[1] = 1040;
  sweedY[2] = 1040;
  sweedY[3] = 80;
  sweedY[4] = 1040;
  sweedY[5] = 320;
  sweedY[6] = 1040;

  sweedYback = new int[7];
  sweedYback[0] = 320;
  sweedYback[1] = 1040;
  sweedYback[2] = 1040;
  sweedYback[3] = 80;
  sweedYback[4] = 1040;
  sweedYback[5] = 320;
  sweedYback[6] = 1040;

  back = new int[7]; 
  for (int i = 0; i < 7; i++) {
    back[i] = sweedYback[i] + 500;
  }

  //background colors

  underwater = color(18, 170, 190);
  sky = color(255);

  //water

  waterlevel = 200;
}


//Draw Function
void draw() {
  background(bC);
  noStroke();
  //Seaweed, feel free to play around and move it accordingly
  swap = 0;
  if ((scene >= 0) && (scene < 4)) {
    bC = underwater;
    seaweeds(0, 320, 1, 0.03);  
    seaweeds(1000, 1040, 0.5, 0.03);
    swap = 1;
    seaweeds(0, 1040, 0.5, 0.03);
    seaweeds(375, 80, 1.5, 0.03);
    swap = 2;
    seaweeds(800, 1040, 0.5, 0.03);
    seaweeds(500, 320, 1, 0.03);
    swap = 0;
    seaweeds(-200, 1040, 0.5, 0.03);
  }
  //drawMonster(200, 200, 0.5);


  //if (scene >= 1) {
  // if (fx > 650) {
  //   float vx;
  //   float vy;
  //   vx = -5;
  //   vy = 0;
  //   fx += vx;
  //   fy += vy;
  //   FirstFish(fx, fy);
  // } 
  // if (fx <= 650) {
  //   FirstFish(650, fy);
  //   println("boom");
  // }
  //}


  //SCENE 1

  /*
  if (scene == 1){
   for (int i = 0; i < s1; i++){
   int s1x;
   float s1y;
   int s1r;
   s1x = -25;
   s1y = 340;
   s1r = 5;
   ManyFish(s1x+i, s1y, s1r, 1, 255);
   s1x += 1;
   println(s1x);
   //s1y = 100*sin(s1y);
   if (s1x < 340){
   s1x += 1;
   } else {
   s1x = 341;
   {
   
   
   }
   }
   }
   }
   */

  // Scene 1 (first fish appears)
  if (scene >= 1) {
    FirstFishAnimate();

    if (fx > 700) {
      float vx;
      float vy;
      vx = -3;
      vy = 0;
      /*
    if (fy > 200){
       vy = sin(1);
       } else if ((fy > 300) && (fy > 200)){
       vy = sin(-1);
       }
       */
      //vy = -1;
      fx += vx;
      fy += vy;

      drawFirstFish(fx, fy, -1, 0, #C80000, 255);

      //if (fy < 100) {
      //  vy = 1;
      //  fy += vy;
      //  drawFirstFish(fx, fy, -1, 0, #C80000, 255);
      //}

      //if (fy > 500) {
      //  vy = -1;
      //  fy += vy;
      //        drawFirstFish(fx, fy, -1, 0, #C80000, 255);
      //}
    }


    if (fx <= 700) {
      if (scene <= 2) {
        drawFirstFish(700, fy, -1, 0, #C80000, 255);
      }
      if (scene >= 3) {
        float vx;
        float vy;
        vx = -3;
        vy = 0;
        /*
    if (fy > 200){
         vy = sin(1);
         } else if ((fy > 300) && (fy > 200)){
         vy = sin(-1);
         }
         */
        //vy = -1;
        fx += vx;
        fy += vy;

        drawFirstFish(fx, fy, -1, 0, #C80000, 255);
      }
    }
  }

  //Scene 2 (sea monster appears)
  if (scene == 2) {
    /*for (int i = 0; i < s2; i++){
     fill(18,170,190);
     rect(0,0, width, height*0.65);
     int x;
     int y;
     x = -500 + 5*i;
     y = height/2;
     drawMonster(x, y, 0.5);
     }
     */

    if (px < 300) {
      float vx;
      float vy;
      vx = 6;
      vy = -1;
      //vy = 1*sin(radians(359));
      px += vx;
      py += vy;
      //println(px);
      drawMonster(px, py, 0.5);
    }
    if (px >= 300) {
      drawMonster(300, py, 0.5);
      //println("done");
    }
  }

  // Scene 3 (bunch of fish come out after sea monster)
  if (scene >= 3) {
    fishAnimate();
    for (int i = 0; i < fishNumber; i++) {
      //fish(fishLoc[i].x, fishLoc[i].y, fishScale[i], fishRotate[i], fishColor[i], 255);
      drawFish(fishLoc[i].x, fishLoc[i].y, fishScale[i], fishRotate[i], fishColor[i], 255);
    }


    if (px >= 300) {
      float vx;
      float vy;
      vx = 4;
      vy = 1*sin(radians(359));
      px += vx * 2;
      py += vy;
      drawMonster(px, py, 0.5);
    }
  }


  // SCENE 4 TRANSITION ABOVE WATER

  if ((scene == 4) || (scene == 5)) {

    int vy;
    vy = 2;

    fill(underwater);

    if (wy < height - waterlevel) {
      wy += vy;

      rect(0, wy, width, height+waterlevel);

     // fill(sky);

     // rect(0, wy-(height+waterlevel), width, height+waterlevel);
      bC = sky;


      for (int i = 0; i < 7; i++) {
        sweedY[i] += vy;
      }
      seaweeds(0, sweedY[0], 1, 0.03);  
      seaweeds(1000, sweedY[1], 0.5, 0.03);
      swap = 1;
      seaweeds(0, sweedY[2], 0.5, 0.03);
      seaweeds(375, sweedY[3], 1.5, 0.03);
      swap = 2;
      seaweeds(800, sweedY[4], 0.5, 0.03);
      seaweeds(500, sweedY[5], 1, 0.03);
      swap = 0;
      seaweeds(-200, sweedY[6], 0.5, 0.03);
    } else {
      fill(underwater);
      rect(0, wy, width, height+waterlevel);
    //  fill(sky);
    //  rect(0, wy-(height+waterlevel), width, height+waterlevel);
    }
  }

  //SCENE 5 WITH BOAT
  if (scene == 4 || scene ==5 || scene ==6) {
    boatP=true;
    drawBoat();
    animateBoat();
    //boats position
    if (boatP==true) {
      bpy+=2;
    } else {
      bpy -= 2;
    }
    if (bpy >=210) {
      bpy=210;
    } 

  }
 //SCENE 5 WHEN CLICK FISHER, NET DROPS (NOT DONE YET)
 if (scene ==5){
 }
      
  
  
  //SCENE 6 TRANSITION BACK UNDERWATER
  if (scene == 6) {
      boatP=false;
      if (boatP ==false){
        bpy -= 2;
      }
    float vy;
    vy = -2;
    fill(underwater);
    wy += vy;
    rect(0, wy, width, height+waterlevel+2);
    if (wy<=0){
      wy=0;
    }
//    fill(sky);
 //   rect(0, wy-(height+waterlevel), width, height+waterlevel);
   // bC = underwater;


    for (int i = 0; i < 7; i++) {
      if (back[i] > sweedYback[i]) {
        back[i] += vy;
      }
    }


    seaweeds(0, back[0], 1, 0.03);  
    seaweeds(1000, back[1], 0.5, 0.03);
    swap = 1;
    seaweeds(0, back[2], 0.5, 0.03);
    seaweeds(375, back[3], 1.5, 0.03);
    swap = 2;
    seaweeds(800, back[4], 0.5, 0.03);
    seaweeds(500, back[5], 1, 0.03);
    swap = 0;
    seaweeds(-200, back[6], 0.5, 0.03);


    /*
    seaweeds(0, sweedYback[0] + 500, 1, 0.03);  
     seaweeds(1000, sweedYback[1] + 500, 0.5, 0.03);
     swap = 1;
     seaweeds(0, sweedYback[2] + 500, 0.5, 0.03);
     seaweeds(375, sweedYback[3] + 500, 1.5, 0.03);
     swap = 2;
     seaweeds(800, sweedYback[4] + 500, 0.5, 0.03);
     seaweeds(500, sweedYback[5] + 500, 1, 0.03);
     swap = 0;
     seaweeds(-200, sweedYback[6] + 500, 0.5, 0.03);
     */
  }
} // bracket to end void draw()

// Seaweed Fucnctions

void seaweeds(int x, int y, float scaleS, float greta) {
  pushMatrix();
  scale(scaleS);
  translate(x, y);
  wave(0, 0, greta/6, greta/7, greta/4, greta/5);
  popMatrix();
}

void wave(int posX, int posY, float uheta, float aeta, float ceta, float feta) {
  fill(12, 148, 110);
  theta+=uheta;
  zeta+=aeta;
  beta+=ceta;
  eta+=feta;
  float z = zeta;
  float q = theta;
  float b = beta;
  float e = eta;
  float y;
  if (swap == 0) {
    for (int i=0; i < 25; i++) {
      fill(random(0, 40), 150-(i*0.75), 110-(i*0.75), random(200, 255));
      //fill(random(0,40), (random(140,160)-i*0.75), (random(100,120)-i*0.75));
      //fill(12, 148-i*0.5, 110-i*0.5);
      y = sin(z)*50/2;
      pushMatrix();
      rotate(radians(270));
      translate((i*5)-425+posX, y+posY+400);
      ellipse(0, 0, 25, 25);
      popMatrix();
      z+=50/250f;
    }
    for (int i=0; i < 50; i++) {
      fill(random(0, 40), 150-(i*0.75), 110-(i*0.75), random(200, 255));
      //fill(random(0,40), (random(140,160)-i*0.75), (random(100,120)-i*0.75));
      //fill(12, (int)148-i*0.5, (int)110-i*0.5);
      y = sin(q)*50/2;
      pushMatrix();
      rotate(radians(300));
      translate((i*5)-150+posX, y+posY+580);
      ellipse(0, 0, 15, 15);
      popMatrix();
      q+=50/250f;
    }
    for (int i=0; i < 40; i++) {
      fill(random(0, 40), 150-(i*0.75), 110-(i*0.75), random(200, 255));
      //fill(random(0,40), (random(140,160)-i*0.75), (random(100,120)-i*0.75));
      //fill(12, (int)148-i*0.5, (int)110-i*0.5);
      y = sin(e)*50/2;
      pushMatrix();
      rotate(radians(240));
      translate((i*5)-600+posX, y+posY+175);
      ellipse(0, 0, 30, 30);
      popMatrix();
      e+=50/250f;
    }
    for (int i=0; i < 40; i++) {
      fill(random(0, 40), 150-(i*0.75), 110-(i*0.75), random(200, 255));
      //fill(random(0,40), (random(140,160)-i*0.75), (random(100,120)-i*0.75));
      //fill(12, (int)148-i*0.5, (int)110-i*0.5);
      y = sin(b)*50/2;
      pushMatrix();
      rotate(radians(255));
      translate((i*5)-525+posX, y+posY+330);
      ellipse(0, 0, 20, 20);
      popMatrix();
      b+=50/250f;
      fill(random(0, 40), 150-i*0.75, 110-i*0.75);
      ellipse(posX+425, posY+410, 150, 100);
    }
    fill(12, 148, 110);
    //fill(12,148,110);
    //ellipse(posX+425, posY+410, 150,100);
  } else if (swap == 1) { 
    for (int i=0; i < 35; i++) {
      fill(random(0, 40), 150-(i*0.75), 110-(i*0.75), random(200, 255));
      //fill(random(0,40), (random(140,160)-i*0.75), (random(100,120)-i*0.75));
      //fill(12, 148-i*0.5, 110-i*0.5);
      y = sin(q)*50/2;
      pushMatrix();
      rotate(radians(270));
      translate((i*5)-425+posX, y+posY+400);
      ellipse(0, 0, 25, 25);
      popMatrix();
      q+=50/250f;
    }
    for (int i=0; i < 35; i++) {
      fill(random(0, 40), 150-(i*0.75), 110-(i*0.75), random(200, 255));
      //fill(random(0,40), (random(140,160)-i*0.75), (random(100,120)-i*0.75));
      //fill(12, (int)148-i*0.5, (int)110-i*0.5);
      y = sin(z)*50/2;
      pushMatrix();
      rotate(radians(300));
      translate((i*5)-150+posX, y+posY+580);
      ellipse(0, 0, 15, 15);
      popMatrix();
      z+=50/250f;
    }
    for (int i=0; i < 35; i++) {
      fill(random(0, 40), 150-(i*0.75), 110-(i*0.75), random(200, 255));
      //fill(random(0,40), (random(140,160)-i*0.75), (random(100,120)-i*0.75));
      //fill(12, (int)148-i*0.5, (int)110-i*0.5);
      y = sin(b)*50/2;
      pushMatrix();
      rotate(radians(240));
      translate((i*5)-600+posX, y+posY+175);
      ellipse(0, 0, 30, 30);
      popMatrix();
      b+=50/250f;
    }
    for (int i=0; i < 30; i++) {
      fill(random(0, 40), 150-(i*0.75), 110-(i*0.75), random(200, 255));
      //fill(random(0,40), (random(140,160)-i*0.75), (random(100,120)-i*0.75));
      //fill(12, (int)148-i*0.5, (int)110-i*0.5);
      y = sin(e)*50/2;
      pushMatrix();
      rotate(radians(255));
      translate((i*5)-525+posX, y+posY+330);
      ellipse(0, 0, 20, 20);
      popMatrix();
      e+=50/250f;
      fill(random(0, 40), 150-i*0.75, 110-i*0.75);
      ellipse(posX+425, posY+410, 150, 100);
    }
    fill(12, 148, 110);
    //fill(12,148,110);
    //ellipse(posX+425, posY+410, 150,100);
  } else if (swap == 2) { 
    for (int i=0; i < 30; i++) {
      fill(random(0, 40), 150-(i*0.75), 110-(i*0.75), random(200, 255));
      //fill(random(0,40), (random(140,160)-i*0.75), (random(100,120)-i*0.75));
      //fill(12, 148-i*0.5, 110-i*0.5);
      y = sin(e)*50/2;
      pushMatrix();
      rotate(radians(270));
      translate((i*5)-425+posX, y+posY+400);
      ellipse(0, 0, 25, 25);
      popMatrix();
      e+=50/250f;
    }
    for (int i=0; i < 25; i++) {
      fill(random(0, 40), 150-(i*0.75), 110-(i*0.75), random(200, 255));
      //fill(random(0,40), (random(140,160)-i*0.75), (random(100,120)-i*0.75));
      //fill(12, (int)148-i*0.5, (int)110-i*0.5);
      y = sin(b)*50/2;
      pushMatrix();
      rotate(radians(300));
      translate((i*5)-150+posX, y+posY+580);
      ellipse(0, 0, 15, 15);
      popMatrix();
      b+=50/250f;
    }
    for (int i=0; i < 40; i++) {
      fill(random(0, 40), 150-(i*0.75), 110-(i*0.75), random(200, 255));
      //fill(random(0,40), (random(140,160)-i*0.75), (random(100,120)-i*0.75));
      //fill(12, (int)148-i*0.5, (int)110-i*0.5);
      y = sin(z)*50/2;
      pushMatrix();
      rotate(radians(240));
      translate((i*5)-600+posX, y+posY+175);
      ellipse(0, 0, 30, 30);
      popMatrix();
      z+=50/250f;
    }
    for (int i=0; i < 35; i++) {
      fill(random(0, 40), 150-(i*0.75), 110-(i*0.75), random(200, 255));
      //fill(random(0,40), (random(140,160)-i*0.75), (random(100,120)-i*0.75));
      //fill(12, (int)148-i*0.5, (int)110-i*0.5);
      y = sin(q)*50/2;
      pushMatrix();
      rotate(radians(255));
      translate((i*5)-525+posX, y+posY+330);
      ellipse(0, 0, 20, 20);
      popMatrix();
      q+=50/250f;
      fill(random(0, 40), 150-i*0.75, 110-i*0.75);
      ellipse(posX+425, posY+410, 150, 100);
    }
    fill(12, 148, 110);
    //fill(12,148,110);
    //ellipse(posX+425, posY+410, 150,100);
  }
}

void monsterwave(int posX, int posY) {
  fill(12, 148, 110);
  monsterzeta+=0.04;
  float z = monsterzeta;
  float y;

  for (int i=0; i < 100; i++) {
    fill(random(0, 40), (random(140, 160)-i*0.75), (random(100, 120)-i*0.75));
    fill(12, (int)100-i*0.5, (int)248-i*0.5);
    y = sin(z)*50/2;
    pushMatrix();
    translate((i*5)+250+posX, y+posY+280);
    ellipse(0, 0, 45, 45);

    //eye
    if (i > 98) {
      fill(255, 255, 0);
      translate(-470, -265);
      triangle(470, 250, 470, 270, 490, 260);
      fill(0);
      ellipse(479, 260, 8, 10);

      //bottom fins
    }
    if (i > 60 && i < 62) {
      fill(0, 100, 50);
      translate(0, 50);
      rotate(radians(30));
      translate(-400, -200);
      ellipse(400, 200, 30, 80);
      fill(0, 150, 50);
      translate(420, 180);
      rotate(radians(-10));
      translate(-400, -200);
      ellipse(400, 200, 50, 100);


      //tail
    }
    if (i > 2 && i < 4) {
      fill(0, 100, 50);
      translate(-100, -50);
      rotate(radians(30));
      translate(-200, -200);
      ellipse(200, 200, 220, 80);
      fill(0, 150, 50);
      translate(200, 240);
      rotate(radians(-20));
      translate(-200, -200);
      ellipse(200, 200, 250, 100);


      //top fins
    }
    if (i > 90 && i < 92) {
      fill (0, 150, 50);
      translate(-50, -80);
      rotate(radians(-40)); 
      translate(-200, -200);
      ellipse(200, 200, 100, 200);
    }
    if (i > 86 && i < 88) {
      fill (0, 140, 50);
      translate(-70, -70);
      rotate(radians(-40)); 
      translate(-200, -200);
      ellipse(200, 200, 80, 180);
    }
    if (i > 80 && i < 82) {
      fill (0, 130, 50);
      translate(-65, -45);
      rotate(radians(-50)); 
      translate(-200, -200);
      ellipse(200, 200, 60, 140);
    }
    if (i > 74 && i < 76) {
      fill (0, 120, 50);
      translate(-60, -30);
      rotate(radians(-60)); 
      translate(-200, -200);
      ellipse(200, 200, 40, 120);
    }
    if (i > 68 && i < 70) {
      fill (0, 110, 50);
      translate(-40, -20);
      rotate(radians(-60)); 
      translate(-200, -200);
      ellipse(200, 200, 40, 80);
    }
    if (i > 62 && i < 64) {
      fill (0, 100, 50);
      translate(-30, -20);
      rotate(radians(-70)); 
      translate(-200, -200);
      ellipse(200, 200, 30, 60);
    }

    popMatrix();
    z+=50/350f;
  }
}

void drawMonster(int x, int y, float scaleS) {
  pushMatrix();
  scale(scaleS);
  translate(x, y);
  monsterwave(0, 0);
  popMatrix();
}

// functions for fish
void drawFish (float fishTranslateX, float fishTranslateY, float fishScale, float fishRotate, color fishColor, color fishEyeColor) {
  pushMatrix(); // applies to entire fish
  translate(fishTranslateX, fishTranslateY); // translate entire fish
  rotate(fishRotate); // rotate entire fish
  scale(fishScale); // scale entire fish

  // Body
  fill(fishColor);
  noStroke();
  ellipse(0, 0, 197, 69);
  triangle(-150, 0, -50, -30, -50, 30); // Left
  triangle(50, -30, 150, 0, 50, 30); // Right
  // Tail
  stroke(fishColor);
  strokeWeight(5);
  pushMatrix();
  translate(-150, 0);
  rotate(radians(fishTailMove));
  translate(150, 0);
  line(-150, 0, -187, -25); // END Top Part of Tail
  popMatrix();
  pushMatrix();
  translate(-150, 0);
  rotate(-radians(fishTailMove));
  translate(150, 0);
  stroke(fishColor);
  line(-150, 0, -187, 25);
  popMatrix(); // END Bottom Part of Tail
  // Eye
  fill(fishEyeColor);
  noStroke();
  ellipse(72, -7, 10, 10);

  popMatrix();
}

void fishAnimate() {
  // for Entire Fish
  for (int i = 0; i < fishNumber; i++) {
    fishLoc[i].x = fishLoc[i].x + fishDir[i].x*fishTime;
    fishLoc[i].y = fishLoc[i].y + fishDir[i].y*fishTime;
  }
  // for Tail
  if (fishTailMove > 35) {
    fishTailSwitch = false;
  } else if (fishTailMove < -30) {
    fishTailSwitch = true;
  }
  if (fishTailSwitch == true) {
    fishTailMove+=1;
  } else {
    fishTailMove+=-1;
  }
}

// END functions for fish

// functions for FirstFish

void drawFirstFish (float FirstFishTranslateX, float FirstFishTranslateY, float FirstFishScale, float FirstFishRotate, color FirstFishColor, color FirstFishEyeColor) {
  pushMatrix(); // applies to entire FirstFish

  translate(FirstFishTranslateX, FirstFishTranslateY); // translate entire FirstFish
  rotate(FirstFishRotate); // rotate entire FirstFish
  scale(FirstFishScale); // scale entire FirstFish

  // Body
  fill(FirstFishColor);
  noStroke();
  ellipse(0, 0, 197, 69);
  triangle(-150, 0, -50, -30, -50, 30); // Left
  triangle(50, -30, 150, 0, 50, 30); // Right
  // Tail
  stroke(FirstFishColor);
  strokeWeight(5);
  pushMatrix();
  translate(-150, 0);
  rotate(radians(FirstFishTailMove));
  translate(150, 0);
  line(-150, 0, -187, -25); // END Top Part of Tail
  popMatrix();
  pushMatrix();
  translate(-150, 0);
  rotate(-radians(FirstFishTailMove));
  translate(150, 0);
  stroke(FirstFishColor);
  line(-150, 0, -187, 25);
  popMatrix(); // END Bottom Part of Tail
  // Eye
  fill(FirstFishEyeColor);
  noStroke();
  ellipse(72, 10, 10, 10);

  popMatrix();
}

void FirstFishAnimate() {
  // for Entire Fish
  for (int i = 0; i < FirstFishNumber; i++) {
    FirstFishLoc[i].x = FirstFishLoc[i].x + FirstFishDir[i].x*FirstFishTime;
    FirstFishLoc[i].y = FirstFishLoc[i].y + FirstFishDir[i].y*FirstFishTime;
  }
  // for Tail
  if (FirstFishTailMove > 35) {
    FirstFishTailSwitch = false;
  } else if (FirstFishTailMove < -30) {
    FirstFishTailSwitch = true;
  }
  if (FirstFishTailSwitch == true) {
    FirstFishTailMove+=1;
  } else {
    FirstFishTailMove+=-1;
  }
}


void drawBoat() {
  pushMatrix();
  translate(635, bpy);
  rotate(brotate);
  translate(-635, -295);
  fill(237, 239, 230);
  beginShape(); //whiteish boatunders
  vertex(83, 476);
  vertex(800, 500);
  vertex(1205, 541);
  vertex(1000, 600);
  vertex( 200, 600);
  endShape();
  fill(63, 23, 32);  //backof boat frame
  beginShape();
  vertex(83, 476);
  vertex(800, 500);
  vertex(1205, 541);
  vertex(1200, 556);
  vertex(805, 515);
  vertex(86, 489);
  endShape();
  fill(255); //white shapes of window
  rect(403, 424, 7, 129);
  rect(266, 423, 200, 7);
  beginShape();
  vertex(309, 424);
  vertex(403, 423);
  vertex(403, 436);
  vertex(358, 435);
  vertex(350, 439);
  vertex(347, 499);
  vertex(353, 505);
  vertex(403, 508);
  vertex(407, 534);
  vertex(285, 509);
  vertex(297, 494);
  vertex(321, 498);
  vertex(324, 483);
  endShape(CLOSE);
  beginShape();
  vertex(237, 410);
  vertex(266, 415);
  vertex(410, 421);
  vertex(404, 434);
  vertex(283, 429);
  vertex(285, 445);
  vertex(295, 492);
  vertex(294, 512);
  vertex(259, 510);
  vertex(260, 494);
  vertex(281, 497);
  vertex(266, 429);
  vertex(237, 420);
  endShape(CLOSE);
  fill(119, 48, 42); //door frame
  rect(410, 422, 142, 139);
  fill(63, 23, 32); //door opening
  rect(415, 429, 132, 129, 10, 10, 0, 0);
  fill(255); //white door
  rect(480, 429, 67, 129, 0, 10, 0, 0);
  fill(119, 48, 42); //door knob
  ellipse(495, 510, 10, 12);

  drawFisher();

  fill(106, 174, 239);
  beginShape(); //bottom base
  vertex(95, 500);
  vertex(527, 579);
  vertex(1023, 582);
  vertex(1191, 561);
  vertex(1155, 674);
  vertex(132, 674);
  endShape(CLOSE);
  fill(119, 48, 42);
  beginShape(); //base brown frame
  vertex(83, 476);
  vertex(527, 550);
  vertex(1023, 555);
  vertex(1205, 541);
  vertex(1199, 561);
  vertex(1023, 582);
  vertex(527, 579);
  vertex(95, 500);
  vertex(87, 496);
  endShape(CLOSE);
  fill(186, 187, 203);
  beginShape();
  vertex(237, 410);
  vertex(510, 405);
  vertex(550, 423);
  vertex(410, 424);
  vertex(266, 415);
  endShape(CLOSE);
  popMatrix();
}
void drawFisher() {
  color skintone = color(255, 221, 166);
  pushMatrix();
  translate(200, 100);
  scale(0.8);
  translate(700, 450);
  translate(-200, -100);
  fill(129, 144, 134); //body
  quad(160, 140, 240, 140, 260, 300, 140, 300);
  fill(skintone);
  ellipse(200, 100, 110, 100); //faceframe
  triangle(200, 152, 250, 135, 255, 100); //facetri>
  triangle(200, 152, 150, 135, 145, 100); //facetri<
  fill(100, 81, 66);
  ellipse(169, 100, 49, 49); //glasses<
  ellipse(231, 100, 49, 49); //glasses>
  rect(169+22, 100, 20, 7);//glasses connection
  fill(skintone);
  ellipse(169, 100, 35, 35); //glasses block
  ellipse(231, 100, 35, 35);
  fill(73, 57, 46);
  arc(170, 98, 25, 28, 0, PI); //<eyeframe toppp
  arc(230, 98, 25, 28, 0, PI);
  fill(250);
  arc(170, 100, 25, 28, 0, PI); //<eye
  arc(230, 100, 25, 28, 0, PI); //>eye
  fill(169, 140, 123);
  quad(195, 119-3, 200, 117-3, 200, 123-3, 195, 123-3); //nose<
  quad(205, 119-3, 200, 117-3, 200, 123-3, 205, 123-3); //nose>
  arc(200, 140, 36, 28, -PI, 0); //mouth
  fill(skintone);
  arc(200, 142, 36, 28, -PI, 0); //mouth cover

  fill(73, 57, 46); //eyeballs
  arc(171, 100, 16, 15, 0, PI);
  arc(229, 100, 16, 15, 0, PI);
  rect(155, 90, 27, 4);
  rect(218, 90, 27, 4);

  fill(188, 152, 146); //hatbeanie
  rect(145, 68, 110, 20, 5, 5, 0, 0);
  arc(200, 75, 100, 70, PI, TWO_PI);
  //scarf
  rect(151, 137, 100, 17, 5, 0, 5, 0);
  beginShape();
  vertex(230, 145);
  vertex(245, 145);
  vertex(250, 200);
  vertex(235, 200);
  endShape(CLOSE);
  popMatrix();
}

void animateBoat() {
  if (brotate <= -PI/50) {
    boatD = false;
  }
  if (brotate > random(PI/100, PI/50)) {
    boatD = true;
  }
  if (boatD ==false) {
    brotate += radians(random(0.01,0.03));
  } else {
    brotate -= radians(random(0.01,0.03));
  }
}




// END functions for FirstFish

void mousePressed() {
  scene = scene + 1;
  println(scene);
}
